<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <title>HUD 자세 시각화</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="theme-color" content="#0a0f1a">
  <link rel="manifest" href="manifest.json">
  <link rel="icon" href="icon-192.png">
  <style>
    html, body {
      margin: 0;
      padding: 0;
      background: #0a0f1a;
      overflow: hidden;
      height: 100vh;
      width: 100vw;
      font-family: monospace;
      color: #00ffff;
    }
    #hudCanvas {
      position: absolute;
      top: 0;
      left: 0;
      z-index: 0;
    }
    #graphCanvas {
      position: absolute;
      bottom: 100px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 5;
    }
    #info {
      position: absolute;
      top: 10px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0,0,0,0.6);
      padding: 10px 20px;
      border-radius: 8px;
      text-align: center;
    }
    #controls {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 10;
    }
    button {
      padding: 10px 25px;
      font-size: 1rem;
      background: transparent;
      color: #00ffff;
      border: 2px solid #00ffff;
      border-radius: 10px;
      cursor: pointer;
    }
    button:hover {
      background: #00ffff;
      color: #000;
    }
  </style>
</head>
<body>
  <canvas id="hudCanvas"></canvas>
  <canvas id="graphCanvas" width="320" height="80"></canvas>

  <div id="info">
    <div>Yaw: <span id="yaw">0</span>° (<span id="direction">-</span>)</div>
    <div>Pitch: <span id="pitch">0</span>°</div>
    <div>Roll: <span id="roll">0</span>°</div>
  </div>

  <div id="controls">
    <button onclick="resetReference()">RESET</button>
  </div>

  <script>
    const hudCanvas = document.getElementById("hudCanvas");
    const hudCtx = hudCanvas.getContext("2d");
    const graphCanvas = document.getElementById("graphCanvas");
    const graphCtx = graphCanvas.getContext("2d");
    const graphData = [];

    let yawOffset = 0, pitchOffset = 0, rollOffset = 0;
    let lastYaw = 0, lastPitch = 0, lastRoll = 0;

    // 보정 필터 변수
    let filteredYaw = 0, filteredPitch = 0, filteredRoll = 0;
    const alpha = 0.1; // 보정 필터 계수

    function resetReference() {
      yawOffset = filteredYaw;
      pitchOffset = filteredPitch;
      rollOffset = filteredRoll;
    }

    function getDirectionText(yaw) {
      const d = Math.round(yaw);
      if (d >= 45 && d < 135) return "E";
      if (d >= 135 && d < 225) return "S";
      if (d >= 225 && d < 315) return "W";
      return "N";
    }

    function drawHUD(roll, pitch) {
      const w = hudCanvas.width;
      const h = hudCanvas.height;
      hudCtx.clearRect(0, 0, w, h);
      hudCtx.save();
      hudCtx.translate(w / 2, h / 2);
      hudCtx.rotate((roll * Math.PI) / 180);

      hudCtx.strokeStyle = "#00ffff";
      hudCtx.lineWidth = 2;
      const pitchY = pitch * 2;

      hudCtx.beginPath();
      hudCtx.moveTo(-100, pitchY);
      hudCtx.lineTo(100, pitchY);
      hudCtx.stroke();

      hudCtx.setLineDash([6, 4]);
      hudCtx.strokeStyle = "#ff4444";
      [-100, 100].forEach(x => {
        hudCtx.beginPath();
        hudCtx.moveTo(x, -100);
        hudCtx.lineTo(x, 100);
        hudCtx.stroke();
      });
      hudCtx.setLineDash([]);

      hudCtx.beginPath();
      hudCtx.moveTo(0, -20);
      hudCtx.lineTo(0, 20);
      hudCtx.moveTo(-15, 0);
      hudCtx.lineTo(15, 0);
      hudCtx.stroke();
      hudCtx.restore();
    }

    function drawGraph(roll) {
      const w = graphCanvas.width;
      const h = graphCanvas.height;
      graphData.push(roll);
      if (graphData.length > w) graphData.shift();
      graphCtx.clearRect(0, 0, w, h);
      graphCtx.beginPath();
      for (let i = 0; i < graphData.length; i++) {
        const y = h / 2 - graphData[i];
        if (i === 0) graphCtx.moveTo(i, y);
        else graphCtx.lineTo(i, y);
      }
      graphCtx.strokeStyle = "#00ffff";
      graphCtx.lineWidth = 2;
      graphCtx.stroke();
    }

    function updateOrientation(e) {
      const rawYaw = (e.alpha ?? 0);
      const rawPitch = (e.beta ?? 0);
      const rawRoll = (e.gamma ?? 0);

      // 보정 필터 적용 (지수평활)
      filteredYaw = alpha * rawYaw + (1 - alpha) * filteredYaw;
      filteredPitch = alpha * rawPitch + (1 - alpha) * filteredPitch;
      filteredRoll = alpha * rawRoll + (1 - alpha) * filteredRoll;

      lastYaw = rawYaw;
      lastPitch = rawPitch;
      lastRoll = rawRoll;

      const relYaw = ((filteredYaw - yawOffset + 360) % 360).toFixed(1);
      const relPitch = (filteredPitch - pitchOffset).toFixed(1);
      const relRoll = (filteredRoll - rollOffset).toFixed(1);

      document.getElementById("yaw").textContent = relYaw;
      document.getElementById("pitch").textContent = relPitch;
      document.getElementById("roll").textContent = relRoll;
      document.getElementById("direction").textContent = getDirectionText(parseFloat(relYaw));

      drawHUD(parseFloat(relRoll), parseFloat(relPitch));
      drawGraph(parseFloat(relRoll));
    }

    function resizeCanvas() {
      hudCanvas.width = window.innerWidth;
      hudCanvas.height = window.innerHeight;
    }

    window.addEventListener("resize", resizeCanvas);
    resizeCanvas();

    if (typeof DeviceOrientationEvent !== "undefined" &&
        typeof DeviceOrientationEvent.requestPermission === "function") {
      const btn = document.createElement("button");
      btn.innerText = "센서 허용";
      btn.style.position = "absolute";
      btn.style.top = "50%";
      btn.style.left = "50%";
      btn.style.transform = "translate(-50%, -50%)";
      btn.onclick = () => {
        DeviceOrientationEvent.requestPermission().then(resp => {
          if (resp === "granted") {
            window.addEventListener("deviceorientation", updateOrientation);
            btn.remove();
          }
        });
      };
      document.body.appendChild(btn);
    } else {
      window.addEventListener("deviceorientation", updateOrientation);
    }
  </script>
</body>
</html>